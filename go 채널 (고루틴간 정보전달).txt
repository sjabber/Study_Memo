Go 채널

Go 채널은 그 채널을 통해 고루틴간 데이터를 주고받는 통로이다. 채널은 make(chan 자료형) 함수로
미리 생성되어야 하며, 채널 연산자 <- 를 통해 데이터를 보내고 받는다. 채널은 흔히 goroutine들 사이
데이터를 주고받는데 사용되는데, 상대편이 준비될 때 까지 채널에 대기함으로써 별도의 lock을 걸지
않고도 데이터를 동기화하는데 사용된다. 채널은 실행 흐름을 제거하는 기능이 있고 모든 채널로 사용할
수 있다.(이 때문에 일급시민(first class citizen)이라 한다.) 그리고 채널 자체는 값이 아닌 레퍼런스 타입
이다. 참조타입..?

채널을 생성할 때는 make()함수에 어떤 타입의 데이터를 채널에서 주고받을지 미리 지정해주어야한다.

ex) 
func main() {
// 정수형 채널을 생성한다.
ch := make(chan int)

go func() {
 	 ch <- 123	//채널에 123을 보낸다. 
}()

	var i int 
	i = <- ch		// 채널로부터 123을 받는다.
	println(i)
}

채널로 데이터를 보낼땐	 채널명 <- 데이터 와 같이 사용하고,
채널로부터 데이터를 받을경우	<- 채널명 와 같이 사용한다.

Go 채널은 수신자와 송신자가 서로를 기다리는 속성때문에, 이를 이용하여 Go 루틴이 끝날 때 까지
기다리는 기능을 구현할 수 있다. 즉, 익명함수를 사용한 한 Go 루틴에서 어떤 작업이 실행되고 있을 때,
메인 루틴은 계속 수신하며 대기하게 된다. 익명함수 Go 루틴에서 작업이 끝난 후, done 채널에 true를
보내면, 수신자 메인루틴은 이를 받고 프로그램을 끝내게 된다.

--------------------------------------------------------------
채널 버퍼링 Go 채널은 2가지의 채널이 존재한다. Unbuffered Channel과 Buffered Channel 이 있다.
위에서 설명한 예제는 Unbuffered Channel로 동기식이라 작업이 채널로부터 데이터를 받아오기위해
계속해서 묶여있게된다. 하지만, Buffered Channel을 사용하면 비록 수신자가 받을 준비가 되어있지 않을
지라도 지정된 버퍼만큼 데이터를 보내고 계속 다른 일을 수행할 수 있다.

버퍼 채널은 make(chan type, N) 함수를 통해 생성된다. 두번째 파라미터 N에 사용할 버퍼 개수를 넣는다.
ex) make(chan int, 10)은 10개의 정수형을 갖는 버퍼채널을 만든다.

다만, 버퍼채널을 이용하지 않을 경우 에러를 발생시킨다. 채널에 값을 보내놓고 수신자가 받는 Go 루틴이 없으면
데드락이 걸린다. (별도의 Go 루틴이 없기 때문)



redteam -> StartProject() 함수에서 사용자 번호정보를 고루틴으로 채널통해서 보내
